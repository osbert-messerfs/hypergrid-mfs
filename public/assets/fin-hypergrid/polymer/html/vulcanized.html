<!--
The OpenFin Hypergrid is a high performant canvas based general grid control.  It is implemented as a Polymer HTML5 web-component. See [Polymer](https://www.polymer-project.org/) and [Web Components](http://www.w3.org/TR/components-intro/).
<br>
### Openfin polymerized hypergrid Demo
To see the "pink" demo
- see the [github pages hosted deplyment](http://openfin.github.io/fin-hypergrid/components/fin-hypergrid/demo.html) or
- run the [openfin installer](https://dl.openfin.co/services/download?fileName=hypergrid-demo-installer&config=http://openfin.github.io/fin-hypergrid/components/fin-hypergrid/demo.json)
### The Hypergrid is dependent on several other OpenFin projects
- [fin-canvas](http://stevewirts.github.io/fin-canvas/components/fin-canvas/): a wrapper to provide a simpler interface to the HTML5 canvas component
- [fin-rectangle](http://stevewirts.github.io/fin-rectangle/components/fin-rectangle/): a small library providing Point and Rectangle objects
- [fin-vampire-bar](http://datamadic.github.io/fin-vampire-bar/components/fin-vampire-bar/): a web-component based general scroll bar control
### Pluggable Grid Behaviors
The Hypergrid design makes no assumptions about the data you wish to view which allows for external data sources and external manipulation and analytics.  Manipulations such as sorting, aggregation, and grouping can be achieved using best of breed high-performant real time tools designed for such purposes. All the code that impacts these operations has been factored into an Object called [PluggableGridBehavior](index.html#fin-hypergrid-behavior-default).  A PluggableGridBehavior can be thought of as a traditional tablemodel but with a little more responsibility.  There are Three example PluggableGridBehaviors provided, the base or DefaultGridBehavior, a QGridBehavior, and an InMemoryGridBehavior.
@group OpenFin hypergrid
@element fin-hypergrid
@homepage http://github.com/openfin/fin-hypergrid
--><html><head><style shim-shadowdom="">
/*******************************
          Flex Layout
*******************************/

html /deep/ [layout][horizontal], html /deep/ [layout][vertical] {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

html /deep/ [layout][horizontal][inline], html /deep/ [layout][vertical][inline] {
  display: -ms-inline-flexbox;
  display: -webkit-inline-flex;
  display: inline-flex;
}

html /deep/ [layout][horizontal] {
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

html /deep/ [layout][horizontal][reverse] {
  -ms-flex-direction: row-reverse;
  -webkit-flex-direction: row-reverse;
  flex-direction: row-reverse;
}

html /deep/ [layout][vertical] {
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

html /deep/ [layout][vertical][reverse] {
  -ms-flex-direction: column-reverse;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
}

html /deep/ [layout][wrap] {
  -ms-flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}

html /deep/ [layout][wrap-reverse] {
  -ms-flex-wrap: wrap-reverse;
  -webkit-flex-wrap: wrap-reverse;
  flex-wrap: wrap-reverse;
}

html /deep/ [flex] {
  -ms-flex: 1 1 0.000000001px;
  -webkit-flex: 1;
  flex: 1;
  -webkit-flex-basis: 0.000000001px;
  flex-basis: 0.000000001px;
}

html /deep/ [vertical][layout] > [flex][auto-vertical], html /deep/ [vertical][layout]::shadow [flex][auto-vertical] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][auto] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][none] {
  -ms-flex: none;
  -webkit-flex: none;
  flex: none;
}

html /deep/ [flex][one] {
  -ms-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

html /deep/ [flex][two] {
  -ms-flex: 2;
  -webkit-flex: 2;
  flex: 2;
}

html /deep/ [flex][three] {
  -ms-flex: 3;
  -webkit-flex: 3;
  flex: 3;
}

html /deep/ [flex][four] {
  -ms-flex: 4;
  -webkit-flex: 4;
  flex: 4;
}

html /deep/ [flex][five] {
  -ms-flex: 5;
  -webkit-flex: 5;
  flex: 5;
}

html /deep/ [flex][six] {
  -ms-flex: 6;
  -webkit-flex: 6;
  flex: 6;
}

html /deep/ [flex][seven] {
  -ms-flex: 7;
  -webkit-flex: 7;
  flex: 7;
}

html /deep/ [flex][eight] {
  -ms-flex: 8;
  -webkit-flex: 8;
  flex: 8;
}

html /deep/ [flex][nine] {
  -ms-flex: 9;
  -webkit-flex: 9;
  flex: 9;
}

html /deep/ [flex][ten] {
  -ms-flex: 10;
  -webkit-flex: 10;
  flex: 10;
}

html /deep/ [flex][eleven] {
  -ms-flex: 11;
  -webkit-flex: 11;
  flex: 11;
}

html /deep/ [flex][twelve] {
  -ms-flex: 12;
  -webkit-flex: 12;
  flex: 12;
}

/* alignment in cross axis */

html /deep/ [layout][start] {
  -ms-flex-align: start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

html /deep/ [layout][center], html /deep/ [layout][center-center] {
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}

html /deep/ [layout][end] {
  -ms-flex-align: end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

/* alignment in main axis */

html /deep/ [layout][start-justified] {
  -ms-flex-pack: start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

html /deep/ [layout][center-justified], html /deep/ [layout][center-center] {
  -ms-flex-pack: center;
  -webkit-justify-content: center;
  justify-content: center;
}

html /deep/ [layout][end-justified] {
  -ms-flex-pack: end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

html /deep/ [layout][around-justified] {
  -ms-flex-pack: distribute;
  -webkit-justify-content: space-around;
  justify-content: space-around;
}

html /deep/ [layout][justified] {
  -ms-flex-pack: justify;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

/* self alignment */

html /deep/ [self-start] {
  -ms-align-self: flex-start;
  -webkit-align-self: flex-start;
  align-self: flex-start;
}

html /deep/ [self-center] {
  -ms-align-self: center;
  -webkit-align-self: center;
  align-self: center;
}

html /deep/ [self-end] {
  -ms-align-self: flex-end;
  -webkit-align-self: flex-end;
  align-self: flex-end;
}

html /deep/ [self-stretch] {
  -ms-align-self: stretch;
  -webkit-align-self: stretch;
  align-self: stretch;
}

/*******************************
          Other Layout
*******************************/

html /deep/ [block] {
  display: block;
}

/* ie support for hidden */
html /deep/ [hidden] {
  display: none !important;
}

html /deep/ [relative] {
  position: relative;
}

html /deep/ [fit] {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

body[fullbleed] {
  margin: 0;
  height: 100vh;
}

/*******************************
            Other
*******************************/

html /deep/ [segment], html /deep/ segment {
  display: block;
  position: relative;
  -webkit-box-sizing: border-box;
  -ms-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1em 0.5em;
  padding: 1em;
  background-color: white;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  border-radius: 5px 5px 5px 5px;
}

</style>

<script src="C:/sandbox/20150408new3grid/bootstrapper/raw/polymer/polymer.js"></script>


<style type="text/css">:host {
  display: block;
  position: relative;
}</style>







<script src="C:/sandbox/20150408new3grid/bootstrapper/raw/webcomponentsjs/webcomponents.js"></script>
<!-- <link rel="import" href="../../polymer-gestures.html"> -->


















































</head><body><div hidden="">
<polymer-element name="fin-rectangle" assetpath="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-rectangle/">
  <script>

'use strict';

(function() {

    function pointEqualsPoint(a, b) {
        return a.x === b.x && a.y === b.y;
    }

    function rectangleContains(rect, x, y) {
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result =
            x >= minX &&
            y >= minY &&
            x <= maxX &&
            y <= maxY;

        return result;
    }

    function createPoint(x, y) {

        var that = {};

        /**
         * The x of this point expressed as a number,
         *
         * @property point.x
         * @type number
         * @default '0'
         */
        Object.defineProperty(that, 'x', {
            value: x || 0,
            writable: false,
            enumerable: true,
            configurable: false
        });


        /**
         * The y of this point expressed as a number,
         *
         * @property point.y
         * @type number
         * @default '0'
         */
        Object.defineProperty(that, 'y', {
            value: y || 0,
            writable: false,
            enumerable: true,
            configurable: false
        });


        /**
         *                                                                      .
         *                                                                      .
         * returns an instance of point that is the sum of self and the argument.
         *
         * @method point.plus(point)
         * @param {point} a point to add to self
         * @returns {point} point object.
         */
        that.plus = function(point) {
            var result = createPoint(this.x + point.x, y + point.y);
            return result;
        };


        /**
         *                                                                      .
         *                                                                      .
         * returns an instance of point that is the difference of self and the argument.
         *
         * @method point.minus(point)
         * @param {point} a point to subtract from self
         * @returns {point} point object.
         */
        that.minus = function(point) {
            var result = createPoint(x - point.x, y - point.y);
            return result;
        };


        /**
         *                                                                      .
         *                                                                      .
         * returns an instance of point that is the min x and y of self and the argument.
         *
         * @method point.min(point)
         * @param {point} a point to source min x and min y against self
         * @returns {point} point object.
         */
        that.min = function(point) {
            var result = createPoint(Math.min(x, point.x), Math.min(y, point.y));
            return result;
        };


        /**
         *                                                                      .
         *                                                                      .
         * returns an instance of point that is the max x and y of self and the argument.
         *
         * @method point.max(point)
         * @param {point} a point to source max x and max y against self
         * @returns {point} point object.
         */
        that.max = function(point) {
            var result = createPoint(Math.max(x, point.x), Math.max(y, point.y));
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns distance between the argment and self using the distance formula.
         *
         * @method point.distance(point)
         * @param {point} a point to compute the distance from self
         * @returns {Number} number object.
         */
        that.distance = function(point) {
            var dx = point.x - x,
                dy = point.y - y,
                result = Math.sqrt((dx * dx) + (dy * dy));
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns if both x and y of self is greater than that of the argument.
         *
         * @method point.greaterThan(point)
         * @param {point} a point to compare against self
         * @returns {boolean} boolean value.
         */
        that.greaterThan = function(point) {
            var result = this.x > point.x && y > point.y;
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns if both x and y of self is less than that of the argument.
         *
         * @method point.lessThan(point)
         * @param {point} a point to compare against self
         * @returns {boolean} boolean value.
         */
        that.lessThan = function(point) {
            var result = this.x < point.x && y < point.y;
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns if both x and y of self is greater than or equal to that of the argument.
         *
         * @method point.greaterThanEqualTo(point)
         * @param {point} a point to compare against self
         * @returns {boolean} boolean value.
         */
        that.greaterThanEqualTo = function(point) {
            var result = this.x >= point.x && y >= point.y;
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns if both x and y of self is less than or equal to that of the argument.
         *
         * @method point.lessThanEqualTo(point)
         * @param {point} a point to compare against self
         * @returns {boolean} boolean value.
         */
        that.lessThanEqualTo = function(point) {
            var result = this.x <= point.x && y <= point.y;
            return result;
        };
        that.isContainedWithinRectangle = function(rect) {
            return rectangleContains(rect, this.x, this.y);
        };
        that.equals = function(point) {
            if (!point) {
                return false;
            }
            return pointEqualsPoint(this, point);
        };
        return that;
    }

    function createRectangle(x, y, width, height) {

        var that = {};

        /**
         * The origin of this rectangle expressed as a point object,
         *
         * @property rectangle.origin
         * @type point
         * @default 'point at 0,0'
         */
        var origin = createPoint(x, y);

        /**
         * The extent of this rectangle expressed as a point object,
         *
         * @property rectangle.extent
         * @type point
         * @default 'point at 0,0'
         */
        var extent = createPoint(width, height);

        /**
         * The corner of this rectangle expressed as a point object,
         *
         * @property rectangle.corner
         * @type point
         * @default 'point at 0,0'
         */
        var corner = createPoint(x + width, y + height);

        /**
         * The center of this rectangle expressed as a point object,
         *
         * @property rectangle.center
         * @type point
         * @default 'point at 0,0'
         */
        var center = createPoint(x + (width / 2), y + (height / 2));

        Object.defineProperty(that, 'origin', {
            value: origin,
            writable: false,
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(that, 'extent', {
            value: extent,
            writable: false,
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(that, 'corner', {
            value: corner,
            writable: false,
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(that, 'center', {
            value: center,
            writable: false,
            enumerable: true,
            configurable: false
        });

        /**
         *                                                                      .
         *                                                                      .
         * returns this.origin.y, this may need to change
         *
         * @method rectangle.top()
         */
        that.top = function() {
            return this.origin.y;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.origin.x, this may need to change
         *
         * @method rectangle.left()
         */
        that.left = function() {
            return this.origin.x;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.top() + this.extent.y, this may need to change
         *
         * @method rectangle.bottom()
         */
        that.bottom = function() {
            return this.top() + this.extent.y;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.left() + this.extent.x, this may need to change
         *
         * @method rectangle.right()
         */
        that.right = function() {
            return this.left() + this.extent.x;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.extent.x
         *
         * @method rectangle.width()
         */
        that.width = function() {
            return this.extent.x;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.extent.y
         *
         * @method rectangle.height()
         */
        that.height = function() {
            return this.extent.y;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.extent.x * this.extent.y
         *
         * @method rectangle.area()
         */
        that.area = function() {
            return this.extent.x * this.extent.y;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns a rectangle width 0 and origin x set to argument
         *
         * @method rectangle.flattenXAt(x)
         */
        that.flattenXAt = function(x) {
            var o = this.origin;
            var e = this.extent;
            return createRectangle(x, o.y, 0, e.y);
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns a rectangle height 0 and origin y set to argument
         *
         * @method rectangle.flattenYAt(y)
         */
        that.flattenYAt = function(y) {
            var o = this.origin;
            var e = this.extent;
            return createRectangle(o.x, y, e.x, 0);
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns true if argument point or rectangle is entirely contained inside self
         *
         * @method rectangle.contains(pointOrRect)
         */
        that.contains = function(pointOrRect) {
            var result = pointOrRect.isContainedWithinRectangle(this);
            return result;
        };

        that.isContainedWithinRectangle = function(rect) {
            var result = rect.origin.lessThanEqualTo(this.origin) && rect.corner.greaterThanEqualTo(this.corner);
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * return a Rectangle that is enlarged/shrunk by argument size
         *
         * @method rectangle.insetBy(thickness)
         */
        that.insetBy = function(thickness) {
            var result = createRectangle(
                this.origin.x + thickness,
                this.origin.y + thickness,
                this.extent.x - 2 * thickness,
                this.extent.y - 2 * thickness);
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * return a Rectangle that contains the receiver and the argument
         *
         * @method rectangle.union(rectangle)
         */
        that.union = function(rectangle) {

            var anOrigin = this.origin.min(rectangle.origin),
                aCorner = this.corner.max(rectangle.corner),
                width = aCorner.x - anOrigin.x,
                height = aCorner.y - anOrigin.y,
                result = createRectangle(anOrigin.x, anOrigin.y, width, height);

            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * iterate over all points inside me calling function(x,y) for each
         *
         * @method rectangle.forEach(function)
         */
        that.forEach = function(func) {
            var xstart = this.origin.x;
            var xstop = this.origin.x + this.extent.x;
            var ystart = this.origin.y;
            var ystop = this.origin.y + this.extent.y;
            for (var x = xstart; x < xstop; x++) {
                for (var y = ystart; y < ystop; y++) {
                    func(x, y);
                }
            }
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns a Rectangle that is the area in which the receiver overlaps with the argument.  ifNoneAction is called if there is no intersection; it has arguments this and rectangle passed in
         *
         * @method rectangle.intersect(rectangle,ifNoneAction)
         */
        that.intersect = function(rectangle, ifNoneAction) {

            var point = rectangle.origin,
                myCorner = this.corner,
                left = null,
                right = null,
                top = null,
                bottom = null,
                result = null;

            if (ifNoneAction && !this.intersects(rectangle)) {
                return ifNoneAction.call(this, rectangle);
            }

            if (point.x > this.origin.x) {
                left = point.x;
            } else {
                left = this.origin.x;
            }

            if (point.y > this.origin.y) {
                top = point.y;
            } else {
                top = this.origin.y;
            }

            point = rectangle.corner;
            if (point.x < myCorner.x) {
                right = point.x;
            } else {
                right = myCorner.x;
            }

            if (point.y < myCorner.y) {
                bottom = point.y;
            } else {
                bottom = myCorner.y;
            }
            result = createRectangle(left, top, right - left, bottom - top);
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns true if we overlap with the argument, false otherwise
         *
         * @method rectangle.intersects(rectangle)
         */
        that.intersects = function(rectangle) {

            var rOrigin = rectangle.origin,
                rCorner = rectangle.corner;

            if (rCorner.x <= this.origin.x) {
                return false;
            }
            if (rCorner.y <= this.origin.y) {
                return false;
            }
            if (rOrigin.x >= this.corner.x) {
                return false;
            }
            if (rOrigin.y >= this.corner.y) {
                return false;
            }
            return true;
        };

        return that;
    }

    /**
     *                                                                        .
     *                                                                      .
     * returns an instance of point.
     *
     * @method static.point.create(x,y)
     * @param {Number} the x coordinate
     *    @param {Number} the y coordinate.
     * @returns {point} point object.
     */

    /**
     *                                                                      .
     *                                                                      .
     * returns an instance of rectangle.
     *
     * @method static.rectangle.create(ox,oy,ex,ey)
     * @param {Number} the x origin coordinate
     *    @param {Number} the y origin coordinate.
     *    @param {Number} the width extent.
     *    @param {Number} the height extent.
     * @returns {rectangle} rectangle object.
     */

    /**
     *                                                                      .
     *                                                                      .
     * returns if a rectangle contains x, y.
     *
     * @method static.rectangle.contains(rectangle,x,y)
     * @param {rectangle} an instance of rectangle
     *    @param {Number} the x coordinate.
     *    @param {Number} the y coordinate.
     * @returns {rectangle} rectangle object.
     */
    Polymer('fin-rectangle', { /* jshint ignore:line  */
        point: {
            create: createPoint
        },
        rectangle: {
            create: createRectangle,
            contains: rectangleContains
        }
    });

})();

  </script>
</polymer-element>
<polymer-element name="fin-canvas" assetpath="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-canvas/">
  <template>
    <style>:host {
    overflow: hidden;
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
button {
  position: fixed;
  top: 0px;
  left: 0px;
  height: 0px;
  width: 0px;
  border: none;
  color: transparent;
  background-color: transparent;
  outline: none;
}
div.container {
  position: relative;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
</style>
    <button></button>
    <canvas class="canvas" on-tap="{{fintap}}" on-hold="{{finhold}}" on-holdpulse="{{finholdpulse}}" on-flick="{{finflick}}" on-release="{{finrelease}}" on-trackstart="{{fintrackstart}}" on-track="{{fintrack}}" on-trackend="{{fintrackend}}"></canvas>
  </template>
  <script>

'use strict';
/* globals document, requestAnimationFrame, CustomEvent */

(function() {

    /**
     * charMap is a private property that maps keys strokes to key chars,
     *
     * @property charMap
     * @type Array
     */
    var canvases = [];
    var paintLoopFunction = function(now) {
        for (var i = 0; i < canvases.length; i++) {
            try {
                canvases[i](now);
            } catch (e) {}
        }
        requestAnimationFrame(paintLoopFunction);
    };
    requestAnimationFrame(paintLoopFunction);

    var charMap = [];
    var empty = ['', ''];
    for (var i = 0; i < 256; i++) {
        charMap[i] = empty;
    }

    charMap[27] = ['ESC', 'ESCSHIFT'];
    charMap[192] = ['`', '~'];
    charMap[49] = ['1', '!'];
    charMap[50] = ['2', '@'];
    charMap[51] = ['3', '#'];
    charMap[52] = ['4', '$'];
    charMap[53] = ['5', '%'];
    charMap[54] = ['6', '^'];
    charMap[55] = ['7', '&'];
    charMap[56] = ['8', '*'];
    charMap[57] = ['9', '('];
    charMap[48] = ['0', ')'];
    charMap[189] = ['-', '_'];
    charMap[187] = ['=', '+'];
    charMap[8] = ['DELETE', 'DELETESHIFT'];
    charMap[9] = ['TAB', 'TABSHIFT'];
    charMap[81] = ['q', 'Q'];
    charMap[87] = ['w', 'W'];
    charMap[69] = ['e', 'E'];
    charMap[82] = ['r', 'R'];
    charMap[84] = ['t', 'T'];
    charMap[89] = ['y', 'Y'];
    charMap[85] = ['u', 'U'];
    charMap[73] = ['i', 'I'];
    charMap[79] = ['o', 'O'];
    charMap[80] = ['p', 'P'];
    charMap[219] = ['[', '{'];
    charMap[221] = [']', '}'];
    charMap[220] = ['\\', '|'];
    charMap[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    charMap[65] = ['a', 'A'];
    charMap[83] = ['s', 'S'];
    charMap[68] = ['d', 'D'];
    charMap[70] = ['f', 'F'];
    charMap[71] = ['g', 'G'];
    charMap[72] = ['h', 'H'];
    charMap[74] = ['j', 'J'];
    charMap[75] = ['k', 'K'];
    charMap[76] = ['l', 'L'];
    charMap[186] = [';', ':'];
    charMap[222] = ['\'', '|'];
    charMap[13] = ['RETURN', 'RETURNSHIFT'];
    charMap[16] = ['SHIFT', 'SHIFT'];
    charMap[90] = ['z', 'Z'];
    charMap[88] = ['x', 'X'];
    charMap[67] = ['c', 'C'];
    charMap[86] = ['v', 'V'];
    charMap[66] = ['b', 'B'];
    charMap[78] = ['n', 'N'];
    charMap[77] = ['m', 'M'];
    charMap[188] = [',', '<'];
    charMap[190] = ['.', '>'];
    charMap[191] = ['/', '?'];
    charMap[16] = ['SHIFT', 'SHIFT'];
    charMap[17] = ['CTRL', 'CTRLSHIFT'];
    charMap[18] = ['ALT', 'ALTSHIFT'];
    charMap[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    charMap[32] = ['SPACE', 'SPACESHIFT'];
    charMap[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    charMap[18] = ['ALT', 'ALTSHIFT'];
    charMap[38] = ['UP', 'UPSHIFT'];
    charMap[37] = ['LEFT', 'LEFTSHIFT'];
    charMap[40] = ['DOWN', 'DOWNSHIFT'];
    charMap[39] = ['RIGHT', 'RIGHTSHIFT'];

    charMap[33] = ['PAGEUP', 'PAGEUPSHIFT'];
    charMap[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
    charMap[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT'];
    charMap[36] = ['PAGELEFT', 'PAGELEFTSHIFT'];

    Polymer('fin-canvas', { /* jshint ignore:line */
        /**                                                             .
         * g is the [fin-rectangle](http://stevewirts.github.io/fin-rectangle/components/fin-rectangle/) factory for creating instances of rectangle and point
         *
         * @property g
         * @type fin-rectangle polymer-element
         */
        g: null,

        /**                                                             .
         * canvas is the actual rendering surface that bit-blit to from the buffer
         *
         * @property canvas
         * @type HTMLCanvasElement
         */
        canvas: null,

        /**                                                             .
         * canvasCTX is the cached graphics context from canvas we bit blit to
         *
         * @property canvasCTX
         * @type 2DRenderingContext
         */
        canvasCTX: null,

        /**                                                             .
         * focuser is a button element that is used to simulate proper focus semantics
         *
         * @property focuser
         * @type HTMLButtonElement
         */
        focuser: null,

        /**                                                             .
         * buffer is the offscreen canvas component we draw to that will eventually be bit blit to canvas
         *
         * @property buffer
         * @type HTMLCanvasElement
         */
        buffer: null,

        /**                                                             .
         * ctx is the offscreen cached graphics context from buffer that we draw to
         *
         * @property ctx
         * @type 2DRenderingContext
         */
        ctx: null,

        /**                                                             .
         * fps is how many times a second we check the repaint flag for redrawing
         *
         * @property fps
         * @type Number
         */
        fps: null,

        /**                                                             .
         * mouseLocation is the current position of the mouse pointer
         *
         * @property mouseLocation
         * @type point
         */
        mouseLocation: null,

        /**                                                             .
         * holdPulseCount is the number of times we've been holdpulsed at the same location for this event
         *
         * @property holdPulseCount
         * @type point
         */
        holdPulseCount: -1,

        /**                                                             .
         * dragstart is the origin of a drag region for the selection
         *
         * @property dragstart
         * @type point
         */
        dragstart: null,

        /**                                                             .
         * origin location of the top right corner of the grid according to [getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect)
         *
         * @property origin
         * @type point
         */
        origin: null,

        /**                                                             .
         * bounds is a private property that maps keys strokes to key chars,
         *
         * @property bounds
         * @type Array
         */
        bounds: null,

        /**                                                             .
         * repaintNow is a private property that maps keys strokes to key chars,
         *
         * @property repaintNow
         * @type Array
         */
        repaintNow: false,

        /**                                                             .
         * size is a private property that maps keys strokes to key chars,
         *
         * @property size
         * @type Array
         */
        size: null,

        /**                                                             .
         * mousedown is a private property that maps keys strokes to key chars,
         *
         * @property mousedown
         * @type Array
         */
        mousedown: false,

        /**                                                             .
         * dragging is true if we are currently dragging
         *
         * @property dragging
         * @type boolean
         */
        dragging: false,

        /**                                                             .
         * focused is true if we currently have input focus
         *
         * @property focused
         * @type boolean
         */
        focused: false,

        /**                                                             .
         * repeatKeyCount is how many times we've recieved a key down event from the user holding a key down
         *
         * @property repeatKeyCount
         * @type Number
         */
        repeatKeyCount: 0,

        /**                                                             .
         * repeatKey is the key that is currently being held down
         *
         * @property repeatKey
         * @type char
         */
        repeatKey: null,

        /**                                                             .
         * repeatKeyStartTime is the start time in milliseconds of the initial keydown event of a key that is being held down
         *
         * @property repeatKeyStartTime
         * @type Number
         */
        repeatKeyStartTime: 0,

        /**                                                             .
         * currentKeys is an array of the all the keys that are currently being pressed
         *
         * @property currentKeys
         * @type Array
         */
        currentKeys: [],

        /**
         *                                                                      .
         *                                                                      .
         * is true if the mouse is currently hovering over me
         *
         * @attribute hasMouse
         * @default false
         * @type boolean
         */
        hasMouse: false,

        /**
         *                                                                      .
         *                                                                      .
         * counter to throttle size checking
         *
         * @attribute checkSizeCounter
         * @default 0
         * @type Number
         */
        checkSizeCounter: 0,

        /**
         *                                                                      .
         *                                                                      .
         * a polymer lifecycle callback to initialize the canvas
         *
         * @method ready()
         */
        ready: function() {

            var self = this;
            this.checkSizeCounter = 0;
            this.g = document.createElement('fin-rectangle');
            this.canvas = this.shadowRoot.querySelector('.canvas');
            this.focuser = this.shadowRoot.querySelector('button');
            this.canvasCTX = this.canvas.getContext('2d');

            this.buffer = document.createElement('canvas');
            this.bufferCTX = this.buffer.getContext('2d');

            this.fps = this.getAttribute('fps') || 60;

            this.mouseLocation = this.g.point.create(-1, -1);
            this.dragstart = this.g.point.create(-1, -1);
            //this.origin = this.g.point.create(0, 0);
            this.bounds = this.g.rectangle.create(0, 0, 0, 0);
            this.hasMouse = false;

            this.onmouseover = function() {
                self.hasMouse = true;
            };
            document.addEventListener('mousemove', function(e) {
                if (!self.hasMouse && !self.isDragging()) {
                    return;
                }
                self.finmousemove(e);
            });
            document.addEventListener('mouseup', function(e) {
                self.finmouseup(e);
            });
            document.addEventListener('wheel', function(e) {
                self.finwheelmoved(e);
            });

            this.focuser.addEventListener('focus', function(e) {
                self.finfocusgained(e);
            });
            this.focuser.addEventListener('blur', function(e) {
                self.finfocuslost(e);
            });
            this.addEventListener('mousedown', function(e) {
                self.finmousedown(e);
            });
            this.addEventListener('mouseout', function(e) {
                self.hasMouse = false;
                self.finmouseout(e);
            });
            document.addEventListener('keydown', function(e) {
                self.finkeydown(e);
            });
            document.addEventListener('keyup', function(e) {
                self.finkeyup(e);
            });
            this.addEventListener('click', function(e) {
                self.finclick(e);
            });
            this.addEventListener('dblclick', function(e) {
                self.findblclick(e);
            });

            this.resize();
            this.beginPainting();

        },

        detached: function() {
            this.stopPainting();
        },

        /**
         *                                                                      .
         *                                                                      .
         * return if I have the hidpi attribute set
         *
         * @method isHiDPI()
         */
        isHiDPI: function() {
            return this.getAttribute('hidpi') !== null;
        },

        /**
         *                                                                      .
         *                                                                      .
         * return if I have the bitblit attribute set
         *
         * @method useBitBlit()
         */
        useBitBlit: function() {
            return this.getAttribute('bitblit') !== 'false';
        },

        /**
         *                                                                      .
         *                                                                      .
         * return my one child fin-canvas-component
         *
         * @method getComponent()
         */
        getComponent: function() {
            var comp = this.children[0];
            return comp;
        },

        /**
         *                                                                      .
         *                                                                      .
         * start the paint loop at this.fps rate
         *
         * @method beginPainting()
         */
        beginPainting: function() {
            var self = this;
            this.repaintNow = true;
            this.tickPainter = function(now) {
                self.tickPaint(now);
            };
            canvases.push(this.tickPainter);
        },

        stopPainting: function() {
            canvases.splice(canvases.indexOf(this.tickPainter), 1);
        },

        tickPaint: function(now) {
            var interval = 1000 / this.fps;
            var lastRepaintTime = 0;
            this.checkSizeCounter++;
            if (this.checkSizeCounter < 3 || (this.checkSizeCounter % 45) === 0) {
                this.checksize();
            }
            var delta = now - lastRepaintTime;
            if (delta > interval && this.repaintNow) {
                lastRepaintTime = now - (delta % interval);
                this.paintNow();
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * check to see if my size has changed, if so notify myself
         *
         * @method checksize()
         */
        checksize: function() {

            //this is expensize lets do it at some modulo
            var sizeNow = this.getBoundingClientRect();
            if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
                this.sizeChangedNotification();
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * my size has changed, lets resize
         *
         * @method sizeChangedNotification()
         */
        sizeChangedNotification: function() {
            this.resize();
        },

        /**
         *                                                                      .
         *                                                                      .
         * because HTMLCanvasElement doesn't obey normal HTML5 resize semantics, we need to update canvas and buffer sizes when our size changes
         *
         * @method resize()
         */
        resize: function() {
            this.size = this.getBoundingClientRect();

            this.canvas.width = this.clientWidth;
            this.canvas.height = this.clientHeight;

            this.buffer.width = this.clientWidth;
            this.buffer.height = this.clientHeight;

            //fix ala sir spinka, see
            //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
            //just add 'hdpi' as an attribute to the fin-canvas tag
            var ratio = 1;
            var useBitBlit = this.useBitBlit();
            var isHIDPI = window.devicePixelRatio && this.isHiDPI();
            if (isHIDPI) {
                var devicePixelRatio = window.devicePixelRatio || 1;
                var backingStoreRatio = this.canvasCTX.webkitBackingStorePixelRatio ||
                    this.canvasCTX.mozBackingStorePixelRatio ||
                    this.canvasCTX.msBackingStorePixelRatio ||
                    this.canvasCTX.oBackingStorePixelRatio ||
                    this.canvasCTX.backingStorePixelRatio || 1;

                ratio = devicePixelRatio / backingStoreRatio;



                //this.canvasCTX.scale(ratio, ratio);
            }
            var width = this.canvas.getAttribute('width');
            var height = this.canvas.getAttribute('height');
            this.canvas.width = width * ratio;
            this.canvas.height = height * ratio;
            this.buffer.width = width * ratio;
            this.buffer.height = height * ratio;

            this.canvas.style.width = width + 'px';
            this.canvas.style.height = height + 'px';
            this.buffer.style.width = width + 'px';
            this.buffer.style.height = height + 'px';

            this.bufferCTX.scale(ratio, ratio);
            if (isHIDPI && !useBitBlit) {
                this.canvasCTX.scale(ratio, ratio);
            }

            //this.origin = this.g.point.create(Math.round(this.size.left), Math.round(this.size.top));
            this.bounds = this.g.rectangle.create(0, 0, this.size.width, this.size.height);
            //setTimeout(function() {
            var comp = this.getComponent();
            if (comp) {
                comp.setBounds(this.bounds);
            }
            this.resizeNotification();
            this.paintNow();
            //});
        },

        /**
         *                                                                      .
         *                                                                      .
         * my size has changed, lets resize
         *
         * @method sizeChangedNotification()
         */
        resizeNotification: function() {
            //to be overridden
        },

        /**
         *                                                                      .
         *                                                                      .
         * my bounds with origin 0,0 and width and height set according to [getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect)
         *
         * @method getBounds()
         */
        getBounds: function() {
            return this.bounds;
        },

        /**
         *                                                                      .
         *                                                                      .
         * force a safe paint right now and then flush the buffer to the screen
         *
         * @method paintNow()
         */
        paintNow: function() {
            var self = this;
            this.safePaintImmediately(function(gc) {
                gc.clearRect(0, 0, self.canvas.width, self.canvas.height);
                self.paint(gc);
                self.repaintNow = false;
            });
        },

        safePaintImmediately: function(paintFunction) {
            var useBitBlit = this.useBitBlit();
            var gc = useBitBlit ? this.bufferCTX : this.canvasCTX;
            try {
                gc.save();
                paintFunction(gc);
            } finally {
                gc.restore();
            }
            if (useBitBlit) {
                this.flushBuffer();
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * render the buffered drawing to the screen
         *
         * @method flushBuffer()
         */
        flushBuffer: function() {
            if (this.buffer.width > 0 && this.buffer.height > 0) {
                this.canvasCTX.drawImage(this.buffer, 0, 0);
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * this is the entry point to the view-heirarchy sub-structure painting, passing in the graphics context gc
         *
         * @method paint(gc)
         */
        paint: function(gc) {
            var comp = this.getComponent();
            if (comp) {
                comp._paint(gc);
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse move event
         *
         * @method finmousemove(e)
         */

        finmousemove: function(e) {
            if (!this.isDragging() && this.mousedown) {
                this.beDragging();
                this.dispatchEvent(new CustomEvent('fin-dragstart', {
                    detail: {
                        mouse: this.mouseLocation,
                        keys: this.currentKeys
                    }
                }));
                this.dragstart = this.g.point.create(this.mouseLocation.x, this.mouseLocation.y);
            }
            this.mouseLocation = this.getLocal(e);
            if (this.isDragging()) {
                this.dispatchEvent(new CustomEvent('fin-drag', {
                    detail: {
                        mouse: this.mouseLocation,
                        dragstart: this.dragstart,
                        keys: this.currentKeys
                    }
                }));
            }
            if (this.bounds.contains(this.mouseLocation)) {
                this.dispatchEvent(new CustomEvent('fin-mousemove', {
                    detail: {
                        mouse: this.mouseLocation,
                        keys: this.currentKeys
                    }
                }));
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse down event
         *
         * @method finmousedown(e)
         */
        finmousedown: function(e) {

            this.mouseLocation = this.getLocal(e);
            this.mousedown = true;

            this.dispatchEvent(new CustomEvent('fin-mousedown', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
            this.takeFocus();

        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse up event
         *
         * @method finmouseup(e)
         */
        finmouseup: function() {
            if (this.isDragging()) {
                this.dispatchEvent(new CustomEvent('fin-dragend', {
                    detail: {
                        mouse: this.mouseLocation,
                        dragstart: this.dragstart,
                        keys: this.currentKeys
                    }
                }));
                this.beNotDragging();
            }
            this.mousedown = false;
            this.mouseLocation = this.g.point.create(-1, -1);
            this.dispatchEvent(new CustomEvent('fin-mouseup', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse out event
         *
         * @method finmouseout(e)
         */
        finmouseout: function() {
            if (!this.mousedown) {
                this.mouseLocation = this.g.point.create(-1, -1);
            }
            this.dispatchEvent(new CustomEvent('fin-mouseout', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the wheelmoved event
         *
         * @method finwheelmoved(e)
         */
        finwheelmoved: function(e) {
            if (this.isDragging() || !this.hasFocus()) {
                return;
            }
            e.preventDefault();
            this.dispatchEvent(new CustomEvent('fin-wheelmoved', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys,
                    primitiveEvent: e
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse click event
         *
         * @method finclick(e)
         */
        finclick: function(e) {
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-click', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the release event
         *
         * @method finrelease(e)
         */
        finrelease: function(e) {
            this.holdPulseCount = 0;
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-release', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the flick event
         *
         * @method finflick(e)
         */
        finflick: function(e) {
            if (!this.hasFocus()) {
                return;
            }
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-flick', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the tap event
         *
         * @method fintap(e)
         */
        fintap: function(e) {
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-tap', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the trackstart event
         *
         * @method fintap(e)
         */
        fintrackstart: function(e) {
            if (!this.hasFocus()) {
                return;
            }
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-trackstart', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys,
                    primitiveEvent: e
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the track event
         *
         * @method fintrack(e)
         */
        fintrack: function(e) {
            if (!this.hasFocus()) {
                return;
            }
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-track', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys,
                    primitiveEvent: e
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the trackend event
         *
         * @method fintrackend(e)
         */
        fintrackend: function(e) {
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-trackend', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys,
                    primitiveEvent: e
                }
            }));
        },
        /**
         *                                                                      .
         *                                                                      .
         * handle the hold event
         *
         * @method finhold(e)
         */
        finhold: function(e) {
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-hold', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the holdpulse event
         *
         * @method finholdpulse(e)
         */
        finholdpulse: function(e) {
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-holdpulse', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys,
                    count: this.holdPulseCount++
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse double click event
         *
         * @method findblclick(e)
         */
        findblclick: function(e) {
            this.mouseLocation = this.getLocal(e);
            this.dispatchEvent(new CustomEvent('fin-dblclick', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the keydown event
         *
         * @method finkeydown(e)
         */
        finkeydown: function(e) {
            if (!this.hasFocus()) {
                return;
            }
            //e.preventDefault();
            var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
            if (e.repeat) {
                if (this.repeatKey === keyChar) {
                    this.repeatKeyCount++;
                } else {
                    this.repeatKey = keyChar;
                    this.repeatKeyStartTime = Date.now();
                }
            } else {
                this.repeatKey = null;
                this.repeatKeyCount = 0;
                this.repeatKeyStartTime = 0;
            }
            if (this.currentKeys.indexOf(keyChar) === -1) {
                this.currentKeys.push(keyChar);
            }
            //console.log(keyChar, e.keyCode);
            this.dispatchEvent(new CustomEvent('fin-keydown', {
                detail: {
                    alt: e.altKey,
                    ctrl: e.ctrlKey,
                    char: keyChar,
                    code: e.charCode,
                    key: e.keyCode,
                    meta: e.metaKey,
                    repeatCount: this.repeatKeyCount,
                    repeatStartTime: this.repeatKeyStartTime,
                    shift: e.shiftKey,
                    identifier: e.keyIdentifier,
                    currentKeys: this.currentKeys.slice(0)
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the keyup event
         *
         * @method finkeyup(e)
         */
        finkeyup: function(e) {
            var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
            this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
            if (!this.hasFocus()) {
                return;
            }
            this.repeatKeyCount = 0;
            this.repeatKey = null;
            this.repeatKeyStartTime = 0;
            this.dispatchEvent(new CustomEvent('fin-keyup', {
                detail: {
                    alt: e.altKey,
                    ctrl: e.ctrlKey,
                    char: keyChar,
                    code: e.charCode,
                    key: e.keyCode,
                    meta: e.metaKey,
                    repeat: e.repeat,
                    shift: e.shiftKey,
                    identifier: e.keyIdentifier,
                    currentKeys: this.currentKeys.slice(0)
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the focusgained event
         *
         * @method finfocusgained(e)
         */
        finfocusgained: function(e) {
            this.focused = true;
            this.dispatchEvent(new CustomEvent('fin-focus-gained', {
                detail: {
                    e: e
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the focuslost event
         *
         * @method finfocuslost(e)
         */
        finfocuslost: function(e) {
            this.focused = false;
            this.dispatchEvent(new CustomEvent('fin-focus-lost', {
                detail: {
                    e: e
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * tickle the repaint flag to on
         *
         * @method repaint()
         */
        repaint: function() {
            this.repaintNow = true;
        },

        /**
         *                                                                      .
         *                                                                      .
         * getter accessor for the mouseLocation field
         *
         * @method getMouseLocation()
         */
        getMouseLocation: function() {
            return this.mouseLocation;
        },

        /**
         *                                                                      .
         *                                                                      .
         * getter accessor for the origin field
         *
         * @method getOrigin()
         */
        getOrigin: function() {
            var rect = this.getBoundingClientRect();
            var p = this.g.point.create(rect.left, rect.top);
            return p;
        },


        /**
         *                                                                      .
         *                                                                      .
         * getter accessor for the local point given a mouse event
         *
         * @method getLocal()
         */
        getLocal: function(e) {
            var rect = this.getBoundingClientRect();
            var p = this.g.point.create((e.x || e.clientX) - rect.left, (e.y || e.clientY) - rect.top);
            return p;
        },

        /**
         *                                                                      .
         *                                                                      .
         * answer if I have focus
         *
         * @method hasFocus()
         */
        hasFocus: function() {
            return this.focused;
        },

        /**
         *                                                                      .
         *                                                                      .
         * try to take global input focus
         *
         * @method takeFocus()
         */
        takeFocus: function() {
            var self = this;
            if (document.activeElement !== this.focuser) {
                setTimeout(function() {
                    self.focuser.focus();
                }, 10);
            }
        },

        beDragging: function() {
            this.dragging = true;
            this.disableDocumentElementSelection();
        },

        beNotDragging: function() {
            this.dragging = false;
            this.enableDocumentElementSelection();
        },

        isDragging: function() {
            return this.dragging;
        },

        disableDocumentElementSelection: function() {
            var style = document.body.style;
            style.cssText = style.cssText + '-webkit-user-select: none';
        },

        enableDocumentElementSelection: function() {
            var style = document.body.style;
            style.cssText = style.cssText.replace('-webkit-user-select: none', '');
        }

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-vampire-bar" attributes="" assetpath="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-vampire-bar/">
  <template>
    <style>
    .scroll-bar {
      width: 13px;
      position: absolute;
      top:0;
      bottom:0;
      background-color: #E7E7E7;
      border: 1px solid #DDDDDD;
    }
    .scroll-bar-gutter {
      position: absolute;
      top: 0%;
      bottom: 0%;
      right: 0%;
      left: 0%;
      margin-top: 15px;
      margin-bottom: 35px;
      border-radius:4px;
    }
    .scroll-bar.horizontal {
      height: 13px;
      width: 100%;
      position: absolute;
      left:0;
      right: 100%;
      top:100%;
    }

    .horizontal .scroll-bar-gutter {
      position: absolute;
      top: 0%;
      bottom: 0%;
      right: 0%;
      left: 0%;
      margin-top: 0px;
      margin-bottom: 0px;
      margin-left: 15px;
      margin-right: 34px;
    }

    .scroll-bar-up {
      position: absolute;
      top: 1px;
      left: 1px;
      width: 12px;
      height: 12px;
      background-color: #B6B6B6;
      border-radius:4px;

      -o-transition:background-color .1s ease-in;
      -ms-transition:background-color .1s ease-in;
      -moz-transition:background-color .1s ease-in;
      -webkit-transition:background-color .1s ease-in;
      /* ...and now for the proper property */
      transition:background-color .1s ease-in;

    }

    .scroll-bar.horizontal .scroll-bar-up {
      position: absolute;
      top: 1px;
      right: 1px;
      left: auto;
      width: 12px;
      height: 12px;
    }

    .scroll-bar-thumb {
      background-color: #B6B6B6;
      width: 8px;
      height: 20px;
      top: 0;
      left: 3px;
      position: absolute;
      border-radius:6px;

      -o-transition:background-color .1s ease-in;
      -ms-transition:background-color .1s ease-in;
      -moz-transition:background-color .1s ease-in;
      -webkit-transition:background-color .1s ease-in;
      /* ...and now for the proper property */
      transition:background-color .1s ease-in;
    }
    .scroll-bar-thumb:hover, .scroll-bar-up:hover, .scroll-bar-down:hover {
      background-color: #4E4E4E;
    }
/*    .scroll-bar-thumb:mousedown {

    }*/

    .scroll-bar.horizontal .scroll-bar-thumb {
      height: 8px;
      width: 20px;
      left: 0px;
      top: 3px;
      position: absolute;
    }

    .scroll-bar-down {
      position: absolute;
      bottom: 1px;
      left: 1px;
      width: 12px;
      height: 12px;
      background-color: #B6B6B6;
      border-radius:4px;

      -o-transition:background-color .1s ease-in;
      -ms-transition:background-color .1s ease-in;
      -moz-transition:background-color .1s ease-in;
      -webkit-transition:background-color .1s ease-in;
      /* ...and now for the proper property */
      transition:background-color .1s ease-in;
    }
    .scroll-bar.horizontal .scroll-bar-down {
      position: absolute;
      top: 1px;
      left: 1px;
      width: 12px;
      height: 12px;
    }

    </style>
    <div class="scroll-bar">
      <div on-holdpulse="{{onUpHold}}" on-tap="{{onUpClick}}" class="scroll-bar-up"></div>
      <div on-holdpulse="{{onGutterHold}}" on-tap="{{onGutterClick}}" class="scroll-bar-gutter">
        <div class="scroll-bar-thumb" draggable="false"></div>
      </div>
      <div on-holdpulse="{{onDownHold}}" on-tap="{{onDownClick}}" class="scroll-bar-down"></div>
    </div>
  </template>

  <script>

'use strict';

(function() {

    // # scroll-bar.js
    //
    // This module defines a custom `<scroll-bar>` element and attaches it to the
    // document.
    //

    var noop = function() {};
    var //templateHolder = document.createElement('div'),
    //SCROLL_BAR_BUTTON_SIZE = 15,
        throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) {
            options = {};
        }

        var later = function() {
            previous = options.leading === false ? 0 : Date.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) {
                context = args = null;
            }
        };
        return function() {
            var now = Date.now();
            if (!previous && options.leading === false) {
                previous = now;
            }
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
                if (!timeout) {
                    context = args = null;
                }
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    };

    //templateHolder.innerHTML = require('./templates.js').scrollbar();



    //ScrollBar.prototype = Object.create(window.HTMLElement.prototype);

    Polymer('fin-vampire-bar', { /* jshint ignore:line  */

        setRangeAdapter: function(rangeAdapter) {

            var that = this;

            that.rangeAdapter = rangeAdapter;
            if (that.thumb) {
                that.thumb.rangeAdapter = rangeAdapter;
            }

            rangeAdapter.valueChanged = function() {
                var value = rangeAdapter.getValue();
                if (value || value === 0) {
                    try {
                        that.supressUpdates = true;
                        that.moveToPercent(value);
                    } finally {
                        that.supressUpdates = false;
                    }
                }
            };

        },

        offset: 0,

        // the createdCallback method will be called by the native code
        attached: function() {

            var that = this;

            // get the actionable child elements
            this.bar = this.shadowRoot.querySelector('.scroll-bar');
            this.thumb = this.shadowRoot.querySelector('.scroll-bar-thumb');
            this.gutter = this.shadowRoot.querySelector('.scroll-bar-gutter');

            this.stepUp = this.shadowRoot.querySelector('.scroll-bar-up');
            this.stepDown = this.shadowRoot.querySelector('.scroll-bar-down');

            this.configureOrientation();

            //var bounds = that.bounds = that.getBoundingClientRect();
            that.isScrolling = false;

            that.attachThumbMouseDown()
                .attachThumbMouseMove()
                .attachThumbMouseUp();
        }, // end attaached


        throttledWheelEvent: throttle(function(event) {

            var that = this;

            var directionXY = that.orientation.toUpperCase(),
                styleProperty = directionXY === 'Y' ? 'top' : 'left',
                rangeStop = that.rangeAdapter.rangeStop(),
                currentPercent = ((that.thumb.style && that.thumb.style[styleProperty]) && parseFloat(that.thumb.style[styleProperty])) || 0,
                direction = event['delta' + directionXY] > 0 ? 1 : -1,
                currentPercentAsRows = Math.round(that.rangeAdapter.rangeStop() * currentPercent),
                oneMoreRow = Math.round(currentPercentAsRows + (1 * direction)),
                ranged = oneMoreRow / rangeStop / 100;

            ranged = ranged > 1 ? 1 : ranged;
            ranged = ranged < 0 ? 0 : ranged;

            that.rangeAdapter.setValue(ranged);

        }, 30),

        attachWheelEvent: function() {
            var that = this;

            document.addEventListener('wheel', function(event) {
                // dont pull on the page at all
                event.preventDefault();
                that.throttledWheelEvent(event);
            });

            return that;
        },

        attachThumbMouseDown: function() {
            var that = this;

            that.thumb.addEventListener('mousedown', function(event) {
                noop(event);
                that.isScrolling = true;
                var direction = that.orientation === 'y' ? 'top' : 'left';
                var distanceFromEdge = that.gutter.getBoundingClientRect()[direction];
                if (that.orientation === 'y') {
                    that.offset = distanceFromEdge + 11; //event.y || event.clientY + distanceFromEdge;
                } else {
                    that.offset = distanceFromEdge + 11; //event.x || event.clientX + distanceFromEdge;
                }

            });

            return that;
        },

        attachThumbMouseMove: function() {
            var that = this;

            document.addEventListener('mousemove', function(event) {
                if (that.isScrolling) {
                    var offset = 0;
                    if (that.orientation === 'y') {
                        offset = event.y || event.clientY;
                    } else {
                        offset = event.x || event.clientX;
                    }
                    that.moveThumb(offset);
                }
            });

            return that;
        },

        attachThumbMouseUp: function() {
            var that = this;
            document.addEventListener('mouseup', function() {
                if (that.isScrolling) {
                    that.offset = 0;
                    that.isScrolling = false;
                }
            });

            return that;
        },



        onUpClick: function() {
            console.log('up click');
        },
        onUpHold: function(event) {
            event.preventTap();
            console.log('hold me up..', Date.now());
        },
        onDownClick: function() {
            console.log('down click');
        },
        onDownHold: function(event) {
            event.preventTap();
            console.log('hold me down ..', Date.now());
        },
        onGutterClick: function() {
            console.log('click');
        },
        onGutterHold: function(event) {
            event.preventTap();
            console.log('hold me in the gutter..', Date.now());
        },

        moveThumb: function(pageLocation) {
            var that = this,
                direction = this.orientation === 'y' ? 'top' : 'left',
                //percent,
                maxScroll = that.getMaxScroll(),
                offBy = pageLocation - that.offset;

            offBy = offBy < 0 ? 0 : offBy;
            offBy = offBy / maxScroll;
            offBy = offBy > 1 ? 1 : offBy;
            offBy = offBy * 100;

            that.thumb.style[direction] = offBy + '%';

            if (that.rangeAdapter) {
                if (that.supressUpdates) {
                    return;
                }
                that.rangeAdapter.setValue(offBy / 100);
            }
        }, //end movethumb value

        moveToPercent: function(percent) {
            var that = this;

            if (!that.isScrolling) {
                that.moveThumb(percent * this.getMaxScroll());
            }
        },


        setValueUpdatedCallback: function(callback) {
            this.valueUpdatedCallback = callback;

        },


        setOrientation: function(orientation) {
            this.orientation = orientation;

        },

        getMaxScroll: function() {
            var direction = this.orientation === 'y' ? 'clientHeight' : 'clientWidth';
            return this.gutter[direction];

        },


        configureOrientation: function() {
            var orientation = 'y';

            if ('horizontal' in this.attributes) {
                orientation = 'x';
                this.bar.classList.add('horizontal');
            }

            this.setOrientation(orientation);
        },

        tickle: function() {
            this.rangeAdapter.setValue(this.lastPercent);
        },

        lastPercent: 0.0,

        createRangeAdapter: function(subject, userConfig) {
            var config = userConfig || {
                    step: 1,
                    page: 40,
                    rangeStart: 0,
                    rangeStop: 100
                },
                that = {};

            // this is the 'cached' value that is listenable
            that.valueObj = {
                value: null
            };

            // apparent Polymer object.observe polyfill breaking change...
            // Object.observe(subject, function() {
            //     that.subjectChanged();
            // });

            that.subjectChanged = function() {
                that.valueObj.value = that.computeNormalizedValue();
                that.valueChanged();
            };

            // that.grid = function(value) {
            //     if (value === undefined) {
            //         return grid;
            //     }
            //     grid = value;
            // };

            that.rangeStart = function(value) {
                if (value === undefined) {
                    return config.rangeStart;
                }
            };

            that.rangeStop = function(value) {
                if (value === undefined) {
                    return config.rangeStop;
                }
            };

            that.page = function(value) {
                if (value === undefined) {
                    return config.page;
                }
            };

            // @param value is a number
            that.setValue = function(newValue) {
                if (typeof newValue !== 'number') {
                    return;
                }
                var deNormalized = Math.floor((newValue * (config.rangeStop - config.rangeStart)) + config.rangeStart);
                subject.setValue(deNormalized);
                that.valueObj.value = newValue;
                that.valueChanged();
            };
            that.computeNormalizedValue = function() {
                var value = (subject.getValue() - config.rangeStart) / (config.rangeStop - config.rangeStart);
                return value;
            };

            that.getValue = function() {
                return that.valueObj.value;
            };

            that.valueChanged = function() {};


            return that;
        }

    });

})();

  </script>
</polymer-element>
<polymer-element name="fin-hypergrid-dnd-list" attributes="label list" assetpath="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid-dnd-list/">
  <template>
    <!-- <link href='http://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'> -->
    <style type="text/css">:host {
  display: block;
  position: relative;
}
* {
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}
.dnd-header {
  z-index: 1;
  font-family: 'Roboto', sans-serif;
  text-transform: capitalize;
  position: relative;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  width: 90%;
  height: 46px;
  background-color: #00796b;
  color: white;
  margin-left: 5%;
  box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
  overflow: hidden;
}
.list {
  background-color: white;
  position: absolute;
  top: 46px;
  left: 5%;
  right: 5%;
  overflow-y: auto;
  list-style-type: none;
  margin: 0px;
  padding-top: 0px;
  padding-left: 0px;
  bottom: 10%;
  box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
}
.controls {
  position: absolute;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  width: 100%;
  bottom: 0%;
  height: 10%;
}

.level1 {
  opacity: 0.7;
  z-index: 2;
  position: absolute;
  box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
  -webkit-transform: translate(-2px,-2px);
     -moz-transform: translate(-2px,-2px);
      -ms-transform: translate(-2px,-2px);
       -o-transform: translate(-2px,-2px);
          transform: translate(-2px,-2px);
}
.level2 {
  opacity: 0.7;
  z-index: 2;
  position: absolute;
  border: 1px solid #e0e0e0;
  box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
  -webkit-transform: translate(-4px,-4px);
     -moz-transform: translate(-4px,-4px);
      -ms-transform: translate(-4px,-4px);
       -o-transform: translate(-4px,-4px);
          transform: translate(-4px,-4px);
}
.level3 {
  opacity: 0.7;
  z-index: 2;
  position: absolute;
  border: 1px solid #e0e0e0;
  box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
  -webkit-transform: translate(-6px,-6px);
     -moz-transform: translate(-6px,-6px);
      -ms-transform: translate(-6px,-6px);
       -o-transform: translate(-6px,-6px);
          transform: translate(-6px,-6px);
}
.level4 {
  opacity: 0.7;
  z-index: 2;
  position: absolute;
  border: 1px solid #e0e0e0;
  box-shadow: 0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22);
  -webkit-transform: translate(-8px,-8px);
     -moz-transform: translate(-8px,-8px);
      -ms-transform: translate(-8px,-8px);
       -o-transform: translate(-8px,-8px);
          transform: translate(-8px,-8px);
}
.level5 {
  opacity: 0.7;
  z-index: 2;
  position: absolute;
  border: 1px solid #e0e0e0;
  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);
  -webkit-transform: translate(-10px,-10px);
     -moz-transform: translate(-10px,-10px);
      -ms-transform: translate(-10px,-10px);
       -o-transform: translate(-10px,-10px);
          transform: translate(-10px,-10px);
}
.spacer {
  visibility: hidden;
  overflow: hidden;
}
.transition {
  transition: height 200ms ease-in;
}
.beSmall {
  height: 0px;
}
.beBig {
  height: 51px;
}
</style>

        <div class="font-special toolbar dnd-header">{{title}}</div>
        <ul id="ulist" class="font-special list" touch-action="pan-y" size="3">
          <template repeat="{{item, i in list}}">
            <li value="{{idAdapter(i)}}_spacer" class="spacer beSmall"></li>
            <li value="{{idAdapter(i)}}" class="item" style="-moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select:none;white-space:nowrap;line-height: 46px;list-style-type: none;font-family: 'Roboto', sans-serif;border-bottom: 1px solid #e0e0e0;text-transform: capitalize;cursor: move;background-color: white;color: black;">
              <span style="font-size: 30px;color: #b6b6b6;margin: 8px;position: relative;top: 2px;cursor: move;">
                ⬤
              </span>
              {{labelAdapter(item)}}
            </li>
          </template>
            <li value="last_spacer" class="spacer beSmall"></li>
        </ul>
      

  </template>
  <script>

/* global PolymerGestures */
'use strict';

(function() {
    var noop = function() {

    };
    Polymer('fin-hypergrid-dnd-list', { /* jshint ignore:line  */
        label: 'label',
        id: 'id',
        attached: function() {
            // populate the element’s data model
            // (the salutations array)
            this.title = this.title || 'title';
            this.list = this.list || [{
                id: 0,
                label: 'list item zero',
            }, {
                id: 1,
                label: 'list item one',
            }, {
                id: 2,
                label: 'list item two',
            }, {
                id: 3,
                label: 'list item three',
            }, {
                id: 4,
                label: 'list item four',
            }, {
                id: 5,
                label: 'list item five',
            }, {
                id: 6,
                label: 'list item six',
            }, {
                id: 7,
                label: 'list item seven',
            }, {
                id: 8,
                label: 'list item eight',
            }, {
                id: 9,
                label: 'list item nine',
            }, ];
            var parent = this.parentElement;
            var self = this;
            parent.oncontextmenu = function() {
                return false;
            };
            PolymerGestures.addEventListener(this.$.ulist, 'trackstart', function(e) {
                var li = e.path[0];
                if (li.nodeName !== 'LI') {
                    return; // not a list item; ignore
                }
                self.initiateItemDrag(li, e);
            });
        },
        getRowHeights: function() {
            var bounds = this.$.ulist.getBoundingClientRect();
            var items = this.$.ulist.querySelectorAll('li.item').array();
            if (items.length === 0) {
                return [0];
            }
            var boundries = items.map(function(e) {
                return e.getBoundingClientRect().top - bounds.top;
            });
            var last = items[items.length - 1];
            boundries.push(boundries[boundries.length - 1] + last.getBoundingClientRect().height);
            boundries[0] = 0;
            return boundries;

        },
        //these can be overriden, or the label and id values can be override
        labelAdapter: function(item) {
            if (typeof item === 'object') {
                return item[this.label];
            }
            return item;
        },
        idAdapter: function(item) {
            if (typeof item === 'object') {
                return item[this.id];
            }
            return item;
        },
        //I've just been dragged over, this is the notification
        handleDragHoverEnter: function(dragged, x, y) {
            noop(dragged, x, y);
        },

        //I've just had a dragging operation leave me and
        //begin hovering over another drag target
        handleDragHoverExit: function(dragged, x, y) {
            noop(dragged, x, y);
            this.correctItemState();
        },

        //I'm being dragged over
        handleDragOver: function(dragged, x, y) {
            var self = this;
            var bounds = this.$.ulist.getBoundingClientRect();
            //var items = this.$.ulist.querySelectorAll('li.item').array();
            var boundries = this.getRowHeights();
            var localY = y - bounds.top;
            var minValue = 1000000;
            var minIndex = 0;
            for (var i = 0; i < boundries.length; i++) {
                var distance = Math.abs(localY - boundries[i]);
                if (distance < minValue) {
                    minIndex = i;
                    minValue = distance;
                }
            }
            var overRow = minIndex;
            if (this.overRow !== overRow) {
                if (this.isTransition) {
                    return;
                }
                this.isTransition = true;
                var spacers = this.$.ulist.querySelectorAll('li.spacer');
                //shrink previous if it exists
                if (this.overRow || this.overRow === 0) {
                    var previous = this.$.ulist.querySelector('li.spacer.beBig');
                    if (previous) {
                        previous.classList.add('transition');
                        requestAnimationFrame(function() {
                            previous.classList.remove('beBig');
                            previous.classList.add('beSmall');
                        });
                    }
                }

                //expand current
                this.overRow = overRow;
                var spacer = spacers[overRow];
                spacer.classList.add('transition');
                requestAnimationFrame(function() {
                    spacer.classList.remove('beSmall');
                    spacer.classList.add('beBig');
                    setTimeout(function() {
                        spacer.classList.remove('transition');
                        self.isTransition = false;
                    }, 210);
                });
            }
        },
        handleDrag: function(e) {
            if (!this.dragFodder) {
                return;
            }
            var dragFodderRect = this.dragFodder.getBoundingClientRect();
            var cxo = dragFodderRect.width / 2;
            var cyo = dragFodderRect.height / 2;

            var globalX = (e.x || e.clientX) - this.dragEventStart[0];
            var globalY = (e.y || e.clientY) - this.dragEventStart[1];
            //var sx = this.dragItemStart[0];
            //var sy = this.dragItemStart[1];
            this.setCssLocation(this.dragFodder.style, globalX, globalY);

            //lets check for a drag over....
            //we need to make invisible briefly so as not to
            //obscure what it's over
            this.dragFodder.style.display = 'none';
            var dropTarget = document.elementFromPoint(globalX + cxo, globalY + cyo);
            this.dragFodder.style.display = '';

            if (dropTarget && dropTarget.handleDragOver) {
                if (this.currentDropTarget !== dropTarget) {
                    if (!dropTarget.canDropItem(this.list, dropTarget.list, this.dragFodder.sourceIndex, this.dragFodder.dragItem, e)) {
                        return;
                    }
                    if (this.currentDropTarget) {
                        this.currentDropTarget.handleDragHoverExit(this.dragFodder, globalX + cxo, globalY + cyo);
                    }
                    this.currentDropTarget = dropTarget;
                    this.currentDropTarget.handleDragHoverEnter(this.dragFodder, globalX + cxo, globalY + cyo);
                }
                dropTarget.handleDragOver(this.dragFodder, globalX + cxo, globalY + cyo);
            }
        },

        //lets notify the drop target of a drop
        //the dropItem contains it's source, dragSource
        handleDrop: function(e) {

            noop(e);

            var dropTarget = this.currentDropTarget;
            var dragFodder = this.dragFodder;

            dropTarget.listItemDropped(dragFodder);
        },

        //ive had a list item dropped on me do the proper thing
        listItemDropped: function(listItem) {

            var self = this;

            var dropSpacer = this.$.ulist.querySelector('li.spacer.beBig');
            var items = this.$.ulist.querySelectorAll('li').array();
            var sourceItem = listItem.dragItem;
            var insertIndex = items.indexOf(dropSpacer) / 2;

            var targetRect = dropSpacer.getBoundingClientRect();
            var targetTop = targetRect.top;
            var targetLeft = targetRect.left;

            listItem.style.webkitTransition = '-webkit-transform 150ms ease-in';
            listItem.style.MozTransition = '-moz-transform 150ms ease-in';
            listItem.style.msTransition = '-ms-transform 150ms ease-in';
            listItem.style.oTransition = '-o-transform 150ms ease-in';
            listItem.style.transition = 'transform 150ms ease-in';

            requestAnimationFrame(function() {
                self.setCssLocation(listItem.style, targetLeft, targetTop);
                setTimeout(function() {
                    listItem.parentElement.removeChild(listItem);
                    dropSpacer.classList.remove('beBig');
                    dropSpacer.classList.add('beSmall');
                    self.list.splice(insertIndex, 0, sourceItem);
                    self.overRow = undefined;
                }, 170);
            });




            //this.correctItemState();

            //remove the item from body
        },

        //this function can be replaced to
        //control what can be dragged out and what cannot
        canDragItem: function(list, item, index, e) {
            noop(list, item, index, e);

            //some examples....
            //return list.length > 1; // 1 item must be left
            //return item !== 'sector'; // can't remove sector

            //default allow anything to be dragged out
            return true;
        },

        //this function can be replaced to
        //control what can be dragged out and what cannot
        //the api could be done better given more time,
        //but this will suffice for current needs
        canDropItem: function(sourceList, myList, sourceIndex, item, e) {
            noop(sourceList, myList, sourceIndex, item, e);

            //some examples....
            //return ['sector', 'gics', 'strategy'].indexOf(item) > -1; // 1 item must be in this list
            //return item !== 'sector'; // can't drop sector here

            //default allow anything to be dragged out
            return true;
        },

        initiateItemDrag: function(li, e) {

            //let' attach the this as the drag source to
            //the item were dragging around
            li.dragSource = this;
            li.dragIndex = parseInt(li.getAttribute('value'));
            li.dragItem = this.list[li.dragIndex];

            if (!this.canDragItem(this.list, li.dragItem, li.dragIndex, e)) {
                return;
            }

            this.overRow = undefined;
            var transitions = this.$.ulist.querySelectorAll('.transition').array();
            transitions.forEach(function(e) {
                e.classList.remove('transition');
            });
            e.preventDefault();
            var goAwayer = li.nextElementSibling;
            var bounds = li.getBoundingClientRect();

            var self = this;
            var parent = this.$.ulist;
            var parentBounds = parent.getBoundingClientRect();
            //li.classList.add('level3');
            li.style.width = parentBounds.width + 'px';
            // if (this.dragFodder) {
            //     document.body.removeChild(this.dragFodder);
            // }


            this.list.splice(li.dragIndex, 1);

            this.dragFodder = li;
            this.dragEventStart = [(e.x || e.clientX) - bounds.left, (e.y || e.clientY) - bounds.top];
            //this.dragItemStart = [bounds.left - parentBounds.left, bounds.top - parentBounds.top];

            //lets insert this guy and do a transition to
            //shrink his height
            //goAwayer.classList.remove('transition');
            goAwayer.classList.add('beBig');
            goAwayer.classList.remove('beSmall');

            document.body.appendChild(li);
            PolymerGestures.addEventListener(li, 'track', function(e) {
                self.handleDrag(e);
            });

            PolymerGestures.addEventListener(li, 'trackend', function(e) {
                self.handleDrop(e);
            });

            // PolymerGestures.addEventListener(li, 'up', function(e) {
            //     console.log('up', e);
            // });

            requestAnimationFrame(function() {
                //goAwayer.classList.remove('beBig');
                //goAwayer.classList.add('beSmall');
                //goAwayer.classList.add('transition');
                //wait a little longer than the transition
                //and remove the spacer so as not to have
                //duplicate spacers
                setTimeout(function() {
                    goAwayer.classList.remove('transition');
                }, 210);
            });
            //make the new guy generate touch events

        },
        setCssLocation: function(style, x, y) {
            style.position = 'fixed';
            style.zIndex = 10;
            style.top = 0;
            style.left = 0;
            style.webkitTransform = 'translate(' + x + 'px, ' + y + 'px)';
            style.MozTransform = 'translate(' + x + 'px, ' + y + 'px)';
            style.mmsTransform = 'translate(' + x + 'px, ' + y + 'px)';
            style.oTransform = 'translate(' + x + 'px, ' + y + 'px)';
            style.transform = 'translate(' + x + 'px, ' + y + 'px)';
            style.border = '1px solid #bbbbbb';
            style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        },

        //I no longer have a drop prospect, it has hovered over another drop prospect, correct my expansion state
        correctItemState: function() {
            var self = this;
            var spacer = this.$.ulist.querySelector('li.spacer.beBig');
            if (spacer) {
                requestAnimationFrame(function() {
                    spacer.classList.remove('beBig');
                    spacer.classList.add('beSmall');
                    spacer.classList.add('transition');
                    //wait a little longer than the transition
                    //and remove the spacer so as not to have
                    //duplicate spacers
                    setTimeout(function() {
                        spacer.classList.remove('transition');
                        self.overRow = undefined;
                    }, 210);
                });
            }
        },
    });

})();

  </script>
</polymer-element>
<polymer-element name="fin-canvas-component" class="fin-canvas-component" attributes="layoutProperties" assetpath="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-canvas/">
  <template></template>
  <script>

'use strict';

(function() {

    Polymer('fin-canvas-component', { /* jshint ignore:line */
        ready: function() {
            this.readyInit();
        },
        readyInit: function() {
            this.g = document.createElement('fin-rectangle');
            this.parent = null;
            this.bounds = this.g.rectangle.create(0, 0, 0, 0);
            this.color = this.color || 'black';
            this.backgroundColor = null;
            this.layoutProperties = this.layoutProperties || [0, 0, 1, 0, 1, 0, 0, 0];
            if (typeof this.layoutProperties === 'string') {
                this.layoutProperties = JSON.parse(this.layoutProperties);
            }
        },
        setBounds: function(rectangle) {
            this.bounds = rectangle;
        },
        getBounds: function() {
            return this.bounds;
        },
        _paint: function(gc) {
            try {
                gc.save();
                gc.translate(this.bounds.left(), this.bounds.top());
                // bug in mozilla canvas of mac workaround
                // don't use cliping
                // gc.rect(0, 0, bounds.width(), bounds.height());
                // gc.clip();
                var bgColor = this.getBackgroundColor();
                if (bgColor) {
                    var rect = this.getBounds();
                    gc.beginPath();
                    gc.fillStyle = bgColor;
                    gc.fillRect(0, 0, rect.width(), rect.height());
                    gc.stroke();
                }
                this.paint(gc);
            } finally {
                gc.restore();
            }
        },
        paint: function( /* gc */ ) {},
        getBackgroundColor: function() {
            return this.backgroundColor;
        },
        setBackgroundColor: function(colorValue) {
            this.backgroundColor = colorValue;
        },
        repaint: function() {
            if (this.parent) {
                this.parent.repaint();
            }
        },
        setParent: function(newParent) {
            this.parent = newParent;
        },
        getLayoutProperties: function() {
            return this.layoutProperties;
        },
        setLayoutProperties: function(properties) {
            this.layoutProperties = properties;
        },
        getComponent: function() {
            var comp = this.children[0];
            return comp;
        }
    });

})();

  </script>
</polymer-element>
<polymer-element name="fin-hypergrid-renderer" extends="fin-canvas-component" assetpath="">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/fin-hypergrid-renderer.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-selection-model" assetpath="">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/fin-hypergrid-selection-model.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-excel" assetpath="">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/fin-hypergrid-excel.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-base.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-cell-provider" assetpath="">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/fin-hypergrid-cell-provider.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-key-paging" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}


</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-key-paging.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-cell-click" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}

















































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-cell-click.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-cell-selection" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-cell-selection.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-overlay" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-overlay.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-thumbwheel-scrolling" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-thumbwheel-scrolling.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-cell-editing" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-cell-editing.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-column-sorting" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-column-sorting.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-column-resizing" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-column-resizing.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-column-moving" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-column-moving.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-row-resizing" extends="fin-hypergrid-feature-column-resizing" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-row-resizing.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-feature-on-hover" extends="fin-hypergrid-feature-base" assetpath="/features/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}

























































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/features/fin-hypergrid-feature-on-hover.js"></script>
</polymer-element><polymer-element name="fin-hypergrid-behavior-base" attributes="" assetpath="/behaviors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/behaviors/fin-hypergrid-behavior-base.js"></script>
</polymer-element><polymer-element name="fin-hypergrid-behavior-default" extends="fin-hypergrid-behavior-base" assetpath="/behaviors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/behaviors/fin-hypergrid-behavior-default.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-behavior-gol" extends="fin-hypergrid-behavior-base" assetpath="/behaviors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/behaviors/fin-hypergrid-behavior-gol.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-behavior-in-memory" extends="fin-hypergrid-behavior-base" assetpath="/behaviors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/behaviors/fin-hypergrid-behavior-in-memory.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-behavior-json" extends="fin-hypergrid-behavior-base" assetpath="/behaviors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/behaviors/fin-hypergrid-behavior-json.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-behavior-q" extends="fin-hypergrid-behavior-base" attributes="url" assetpath="/behaviors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/behaviors/fin-hypergrid-behavior-q.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-behavior-qtree" extends="fin-hypergrid-behavior-base" attributes="url" assetpath="/behaviors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/behaviors/fin-hypergrid-behavior-qtree.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-cell-editor-base" assetpath="/cell-editors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/cell-editors/fin-hypergrid-cell-editor-base.js"></script>
</polymer-element><polymer-element name="fin-hypergrid-cell-editor-simple" extends="fin-hypergrid-cell-editor-base" assetpath="/cell-editors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
    <div id="editor"></div>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/cell-editors/fin-hypergrid-cell-editor-simple.js"></script>
</polymer-element><polymer-element name="fin-hypergrid-cell-editor-textfield" extends="fin-hypergrid-cell-editor-simple" assetpath="/cell-editors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
    <input id="editor">
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/cell-editors/fin-hypergrid-cell-editor-textfield.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-cell-editor-choice" extends="fin-hypergrid-cell-editor-simple" assetpath="/cell-editors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
    <select id="editor">
      <option template="" repeat="{{item in items}}" value="{{item}}">{{item}}</option>
    </select>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/cell-editors/fin-hypergrid-cell-editor-choice.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-cell-editor-color" extends="fin-hypergrid-cell-editor-simple" assetpath="/cell-editors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
    <input id="editor" type="color">
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/cell-editors/fin-hypergrid-cell-editor-color.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-cell-editor-date" extends="fin-hypergrid-cell-editor-simple" assetpath="/cell-editors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
    <input id="editor" type="date">
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/cell-editors/fin-hypergrid-cell-editor-date.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-cell-editor-slider" extends="fin-hypergrid-cell-editor-simple" assetpath="/cell-editors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
    <input id="editor" type="range">
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/cell-editors/fin-hypergrid-cell-editor-slider.js"></script>
</polymer-element>
<polymer-element name="fin-hypergrid-cell-editor-spinner" extends="fin-hypergrid-cell-editor-simple" assetpath="/cell-editors/">
  <template>
    <style type="text/css">:host {
    display: block;
    position: relative;
}







































































































































</style>
    <input id="editor" type="number">
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/cell-editors/fin-hypergrid-cell-editor-spinner.js"></script>
</polymer-element></div><polymer-element name="fin-hypergrid" assetpath="">
  <template>
    <link rel="stylesheet" type="text/css" href="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/css/fin-hypergrid.css">
    <fin-plugins>
    </fin-plugins>
    <fin-vampire-bar class="horizontalScroller" horizontal=""></fin-vampire-bar>
    <fin-vampire-bar class="verticalScroller"></fin-vampire-bar>
    <fin-canvas>
      <fin-hypergrid-renderer></fin-hypergrid-renderer>
    </fin-canvas>
    <input class="editor">
    <content></content>
  </template>
  <script src="C:/sandbox/20150408new3grid/bootstrapper/raw/fin-hypergrid/polymer/js/fin-hypergrid.js"></script>
</polymer-element></body></html>